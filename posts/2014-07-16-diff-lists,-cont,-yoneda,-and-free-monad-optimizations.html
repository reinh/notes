<!doctype html>
<html lang>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Rein's Notes - Diff Lists, Cont, Yoneda, and Free Monad Optimizations</title>

    <script src="//use.typekit.net/nmd2mgp.js"></script>
    <script>try{Typekit.load();}catch(e){}</script>

    <link rel="stylesheet" type="text/css" href="../css/katex.min.css">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/site.css">
    <link rel="stylesheet" type="text/css" href="../css/prism.css">
  </head>
  <body>
    <!--[if lt IE 8]>
        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

    <header>
      <h1><a href="../">Rein's Notes</a></h1>
      <!-- <nav> -->
      <!--   <ul> -->
      <!--     <li><a href="/archive.html">Archive</a></li> -->
      <!--   </ul> -->
      <!-- </nav> -->
    </header>

    <section>
      <article>
        <header>
  <h1>Diff Lists, Cont, Yoneda, and Free Monad Optimizations</h1>
  <p>
    Posted on July 16, 2014
    
  </p>
</header>

<div class="body column--left">
  <p class="lead">

What do <a href="https://wiki.haskell.org/Difference_list" title>difference lists</a>, <a href="https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style" title>continuations</a>, the <a href="https://www.fpcomplete.com/user/bartosz/understanding-yoneda" title>Yoneda lemma</a>, and the <a href="http://comonad.com/reader/2011/free-monads-for-less/" title>Codensity trick</a> have in common?

</p>

<p>A continuation in Haskell can be represented with the following type:</p>

<pre><code class="language-haskell">newtype Cont r a = Cont { runCont :: (a -&gt; r) -&gt; r }</code></pre>

<p>This type seems to be daunting to newer Haskell developers. How would you construct such a value? How would you <em>use</em> it once you’ve constructed it? How does this represent a continuation? What even is a continuation?</p>

<p>Let’s take a step back and think about what <a href="http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style" title>continuation passing</a> does in simpler terms: A continuation is a function that is applied to the result of another computation. Continuation passing then inverts the usual control flow, where functions take values and provide values, by having functions take <em>another function</em>, the continuation, which will be <em>provided</em> with the value. This CPS transformation then is some sort of inversion of function application, so let’s just try that and see what happens:</p>

<pre><code class="language-haskell">:t flip ($)
a -&gt; (a -&gt; b) -&gt; b
</code></pre>

<p>By flipping function application, then, we get a function where you first supply a value and <em>then</em> supply some function, or <em>continuation</em>, to be applied to the value. Let’s try this out:</p>

<pre><code class="language-haskell">k = flip ($) 3

main = do
  print $ k succ
  print $ k show
  print $ k sqrt</code></pre>

<p>prints:</p>

<pre><code class>4
&quot;3&quot;
1.7320508075688772</code></pre>

<p>So <code>k</code> is a <em>suspended computation</em> that will apply the value <code>3</code> to any continuation that is passed to it. This is great, but what can we <em>do</em> with it? Let’s start with a problem first tackled by <span class="cite" data-citation-ids="hughes1986novel">Hughes [<a href="#ref-hughes1986novel" title>1986</a>]</span>, the list concatenation problem. The problem is this: constructing a list by repeatedly concatenating onto the end has \(O(2^n)\) performance. This is because each new concatenation must traverse the entire first list before it can add the second list.</p>

<p>The definition of <code>(++)</code> is</p>

<pre><code class="language-haskell">[]     ++ ys  = ys
(x:xs) ++ ys  = x : xs ++ ys</code></pre>

<p>and the evaluation of <code>(&quot;foo&quot; ++ &quot;bar&quot;) ++ &quot;bizz&quot;</code> goes as follows:</p>

<pre><code class="language-haskell">  (&quot;foo&quot; ++ &quot;bar&quot;) ++ &quot;bizz&quot;
= ('f' : &quot;oo&quot; ++ &quot;bar&quot;) ++ &quot;bizz&quot;
= ('f' : 'o' : &quot;o&quot; ++ &quot;bar&quot;) ++ &quot;bizz&quot;
= ('f' : 'o' : 'o' : [] ++ &quot;bar&quot;) ++ &quot;bizz&quot;
= ('f' : 'o' : 'o' : &quot;bar&quot;) ++ &quot;bizz&quot;
= &quot;foobar&quot; ++ &quot;bizz&quot;
= 'f' : &quot;oobar&quot; ++ &quot;bizz&quot;
= ...</code></pre>

<p>and then the entire string <code>&quot;foobar&quot;</code> is traversed again to add <code>&quot;bizz&quot;</code>. The solution is to find some way to reassociate the concatenations so that they associate to the right. List concatenation is defined as right-associative because this gives linear performance:</p>

<pre><code class="language-haskell">  &quot;foo&quot; ++ (&quot;bar&quot; ++ &quot;bizz&quot;)
= 'f' : &quot;oo&quot; ++ (&quot;bar&quot; ++ &quot;bizz&quot;)
= 'f' : 'o' : &quot;o&quot; ++ (&quot;bar&quot; ++ &quot;bizz&quot;)
= 'f' : 'o' : 'o' : [] ++ (&quot;bar&quot; ++ &quot;bizz&quot;)
= 'f' : 'o' : 'o' : (&quot;bar&quot; ++ &quot;bizz&quot;)
= 'f' : 'o' : 'o' : ('b' : &quot;ar&quot; ++ &quot;bizz&quot;)
= 'f' : 'o' : 'o' : ('b' : 'a' : &quot;r&quot; ++ &quot;bizz&quot;)
= 'f' : 'o' : 'o' : ('b' : 'a' : 'r' : [] ++ &quot;bizz&quot;)
= 'f' : 'o' : 'o' : ('b' : 'a' : 'r' : &quot;bizz&quot;)
= &quot;foobarbizz&quot;</code></pre>

<p>Hughes’ novel representation of lists is a <em>CPS transform</em>: Lists represented as <em>continuations</em>:</p>

<pre><code class="language-haskell">rep    :: [a] -&gt; ([a] -&gt; [a])
rep s  = (s++)</code></pre>

<p>This <em>representation</em> can be transformed back into the underlying abstract data type, or <em>abstraction</em>, by applying it to the empty list:</p>

<pre><code class="language-haskell">abs    :: ([a] -&gt; [a]) -&gt; [a]
abs f  = f []</code></pre>

<p>The choice of empty list is not arbitrary: <code>rep</code> and <code>abs</code> witness an isomorphism between the <em>free monoid</em>, a.k.a. <code>[a]</code>, and the <em>endomorphism monoid</em>, <code>a -&gt; a</code>. These monoids are given as:</p>

<pre><code class="language-haskell">instance Monoid [] where
  mempty   = []
  mappend  = (++)

newtype Endo a = Endo { appEndo :: (a -&gt; a) }

instance Monoid Endo where
  mempty   = id
  mappend  = (.)</code></pre>

<p>This means that <code>rep</code> and <code>abs</code> are <em>monoid morphisms</em>, which implies that the equivalent to string concatenation in this CPS representation is function composition, and indeed it is so:</p>

<pre><code class="language-haskell">&gt; abs $ rep &quot;foo&quot; . rep &quot;bar&quot; . rep &quot;bizz&quot;
&quot;foobarbiz&quot;</code></pre>

<hr />

<div class="references">
<div id="ref-hughes1986novel">
<p><span style="font-variant: small-caps;">Hughes, R.J.M.</span> 1986. A novel representation of lists and its application to the function “reverse”. <em>Information processing letters</em> <em>22</em>, 3, 141–144.</p></div></div>
</div>

      </article>

    </section>

    <script src="../js/prism.js"></script>
    <script src="../js/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/contrib/auto-render.min.js">
    </script>

    <script>
    renderMathInElement(
          document.body,
          {
              delimiters: [
                  {left: "\\[", right: "\\]", display: true},
                  {left: "\\(", right: "\\)", display: false}
              ]
          }
    );
    </script>

    <style>
      p, li, dd {
        rag-adjust: small-words;
        widow-adjust: padding-right;
      }
    </style>

    <script src="../js/type.js" type="text/javascript"></script>
  </body>
</html>
