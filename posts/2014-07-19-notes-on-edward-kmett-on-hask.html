<!doctype html>
<html lang>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Rein's Notes - Notes on Edward Kmett on Hask</title>

    <script src="//use.typekit.net/nmd2mgp.js"></script>
    <script>try{Typekit.load();}catch(e){}</script>

    <link rel="stylesheet" type="text/css" href="../css/katex.min.css">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/site.css">
    <link rel="stylesheet" type="text/css" href="../css/prism.css">
  </head>
  <body>
    <!--[if lt IE 8]>
        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

    <header>
      <h1><a href="../">Rein's Notes</a></h1>
      <nav>
        <ul>
          <li><a href="../archive.html">Archive</a></li>
        </ul>
      </nav>
    </header>

    <section>
      <article>
        <header>
  <h1>Notes on Edward Kmett on Hask</h1>
  <p>
    Posted on July 19, 2014
    
  </p>
</header>

<div class="body column--left">
  <p>Notes on <a href="http://comonad.com" title>Edward Kmett</a>’s talk <a href="https://www.youtube.com/watch?v=Klwkt9oJwg0" title>Edward Kmett on Hask</a>.</p>

<h1 id="categories">Categories</h1>

<aside class="sidenote"><ol start="1"><li id="sn1"><div><p>The terms &ldquo;mapping&rdquo;, &ldquo;arrow&rdquo;, and &ldquo;morphism&rdquo; are used pretty much interchangeably in category theory.</p></div></li></ol></aside><p>The Category typeclass represents classes of &ldquo;morphisms&rdquo;<a id="fnref1" class="fnref" href="#fn1"><sup>1</sup></a> (abstract functions) equipped with an identity morphism and composition of morphisms.</p>

<pre><code class="language-haskell">class Category h where
  id   :: h a a
  (.)  :: h b c -&gt; h a b -&gt; h a c</code></pre>

<p>This is the usual notion of a <em>category</em> from <a href="http://en.wikipedia.org/wiki/Category_Theory" title>Category Theory</a> with a few restrictions. Most importantly, this definition restricts us to categories with morphisms of kind <code>*</code>. The rest of this talk will explore the use of <code>PolyKinds</code> to construct <em>higher kinded</em> categories. The motivation for this is the introduction of a higher order morphism known as a <em>natural transformation</em>, and the definition of a category that makes use of them. In order to get there, however, we’ll have to introduce <em>functors</em> first.</p>

<h1 id="functors">Functors</h1>

<p>A <em><a href="http://en.wikipedia.org/wiki/Functor" title>functor</a></em> is a type of mapping between categories. Given two categories \({\mathcal{C}}\) and \({\mathcal{D}}\) and a functor \(F \colon {\mathcal{C}} \to {\mathcal{D}}\), \(F\) maps objects in \({\mathcal{C}}\) to objects in \({\mathcal{D}}\) and arrows in \({\mathcal{C}}\) to arrows in \({\mathcal{D}}\). This mapping must abide by two laws:</p>

<ol>
<li><p>It must preserve identity arrows:</p>

<p>\(F(id_X) = id_{F(X)}\) for every object \(X\) in \({\mathcal{C}}\).</p>

<p>In other words, the \(id\) arrow for the object \(X\) in \({\mathcal{C}}\) must map to the \(id\) arrow for the object \(F(X)\) in \({\mathcal{D}}\).</p></li>
<li><p>It must preserve composition of arrows:</p>

<p>\(F(g \circ f) = F(g) \circ F(f)\) for all arrows \(f \colon X \to Y\) and \(g \colon Y \to Z\).</p>

<p>In other words, the composition of arrows \(f\) and \(g\) in \({\mathcal{C}}\) must map to the composition of arrows \(F(f)\) and \(F(g)\) in \({\mathcal{D}}\).</p></li>
</ol>

<p>The Functor class that comes with Haskell is this sort of functor, but again it is somewhat restricted because it doesn’t parameterize over a choice of category:</p>

<pre><code class="language-haskell">class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></pre>

<aside class="sidenote"><ol start="2"><li id="sn2"><div><p>An <em>endofunctor</em> is a functor that maps from a category to itself.</p></div></li></ol></aside><p>This means that it can only operate in the &ldquo;ambient&rdquo; Haskell category, where the objects are all Haskell types and the arrows are all functions, often called <em>Hask</em>. This also makes them <em>endofunctors</em><a id="fnref2" class="fnref" href="#fn2"><sup>2</sup></a>.</p>

<p>It has a mapping from types to types (this is the instance’s type constructor, e.g., <code>Maybe</code>, which must be of kind <code>* -&gt; *</code>) and a mapping from functions to functions (this is the instance’s implementation of <code>fmap</code>). It must also abide a pair of &ldquo;Functor laws&rdquo; which are precisely the functor laws from category cheory:</p>

<pre><code class="language-haskell">-- fmap sends identity arrows to identity arrows
fmap id = id

-- fmap preserves composition
fmap f . fmap g = fmap (f . g)</code></pre>

<p>Now that we have a way to describe categories explicitly, we can describe Hask itself:</p>

<pre><code class="language-haskell">instance Category (-&gt;) where
  id x = x
  (.) f g b = f (g b)</code></pre>

<p>and we can also describe functors between categories other than Hask! (Unfortunately, we’ll have to get to that bit later since Edward has already jumped ahead to <em>natural transformations</em>!)</p>

<h1 id="natural-transformations">Natural Transformations</h1>

<p>If functors are morphisms of morphisms, it’s reasonable to ask if we can go a step further and get morphisms of morphisms of morphisms, i.e., morphisms of functors. The answer is yes, and they’re called [natural transformations][nat].</p>

<p>Specifically, a natural transformation is a morphism from a Functor to another Functor:</p>

<pre><code class="language-haskell">newtype Nat f g = Nat { runNat :: forall a. f a -&gt; g a }</code></pre>

<p><code>Nat</code> sends a Functor <code>f</code> to a Functor <code>g</code>. It doesn’t care what type the functors are parameterized over as long as it doesn’t change. The <code>RankNTypes</code> extension is needed here to universally quantify (and bind) the <code>a</code> in the inner scope, and thereby &ldquo;hide&rdquo; it it from the outer scope.</p>

<p>Since it’s somewhat unusual to operate at this level of abstraction, it might help to provide a few examples of <code>Nat</code> values. First, we’ll need some functions that serve as functor mappings:</p>

<pre><code class="language-haskell">-- A mapping from [a] to Maybe a
-- NB: This mapping &quot;forgets&quot; the tail of the list.
listToMaybe              :: [a] -&gt; Maybe a
listToMaybe []           = Nothing
listToMaybe (x:xs)       = Just x

-- A mapping from Maybe a to Either () a
-- NB: Either () a is isomorphic to Maybe a
maybeToEither            :: Maybe a -&gt; Either () a
maybeToEither Nothing    = Left ()
maybeToEither (Just x)   = Right x

-- A mapping from Either a b back to Maybe b
-- NB: This mapping &quot;forgets&quot; the left summand.
eitherToMaybe            :: Either a b -&gt; Maybe b
eitherToMaybe (Left _)   = Nothing
eitherToMaybe (Right x)  = Just x</code></pre>

<p>Now we can look at their <code>Nat</code>-encoded versions:</p>

<pre><code class="language-haskell">Nat listToMaybe    :: Nat [] Maybe
Nat maybeToEither  :: Nat Maybe (Either ())
Nat eitherToMaybe  :: Mat (Either a) Maybe</code></pre>

<p>(Note that the Functor’s type argument is hidden by the forall and <code>Rank2Types</code>.)</p>

<p>Since natural transformations are morphisms, it’s also reasonable to ask if they form a category, and it shouldn’t be a surprise that they do. This category is called a <em>functor category</em>.</p>

<h1 id="functor-categories">Functor Categories</h1>

<p>Starting with the observation that the functions defined above can be composed,</p>

<pre><code class="language-haskell">maybeToEither . listToMaybe   :: [a] -&gt; Either () a
maybeToEither . eitherToMaybe :: Either a b -&gt; Either () b
eitherToMaybe . maybeToEither :: Maybe a -&gt; Maybe a</code></pre>

<p>we can also explore the composition of <code>Nat</code> values. The first step is to make a <code>Category</code> instance for <code>Nat</code>:</p>

<pre><code class="language-haskell">instance Category Nat where
  id = Nat id
  Nat f . Nat g = Nat (f . g)</code></pre>

<p>If we try this without <code>PolyKinds</code>, we get a kind error:</p>

<pre><code class>    The first argument of ‘Category’ should have kind ‘* -&gt; * -&gt; *’,
      but ‘Nat’ has kind ‘(* -&gt; *) -&gt; (* -&gt; *) -&gt; *’
    In the instance declaration for ‘Category Nat’</code></pre>

<p>We’re trying to make a <code>Category</code> instance for <code>Nat</code>. Unfortunately, <code>Nat</code> has kind</p>

<pre><code class="language-haskell">:k Nat
(* -&gt; *) -&gt; (* -&gt; *) -&gt; *</code></pre>

<p>because <code>Nat</code> is a mapping of <code>Functor</code>s, which have kind <code>* -&gt; *</code>, while <code>Category</code> instances must have kind <code>* -&gt; * -&gt; *</code>. In other words, <code>Category</code> instances can only map over types of kind <code>*</code>, not types of kind <code>* -&gt; *</code>.</p>

<aside class="sidenote"><ol start="3"><li id="sn3"><div><p><code>PolyKinds</code> was introduced in the paper <a href="http://dreixel.net/research/pdf/ghp.pdf" title>Giving Haskell a Promotion</a> by Yorgey, Weirich, Vytiniotis, and Jones.</p></div></li></ol></aside><p>The solution is to allow <code>Category</code> to map over arbitrarily kinded types. The <a href="https://www.haskell.org/ghc/docs/latest/html/users_guide/kind-polymorphism.html" title><code>PolyKinds</code></a><a id="fnref3" class="fnref" href="#fn3"><sup>3</sup></a> extension lets GHC derive a <em>polymorphic kind</em> for <code>Category</code> so that the kind of <code>Category</code> instances becomes <code>k -&gt; k -&gt; *</code> where <code>k</code> represents any kind.</p>

<p>Now that we have a polymorphically kinded <code>Category</code>, we can construct our instance for <code>Nat</code>. Here it is again for reference:</p>

<pre><code class="language-haskell">instance Category Nat where
  id = Nat id
  Nat f . Nat g = Nat (f . g)</code></pre>

<p>The identity morphism for natural transformations is the always useful <code>id</code>. Composition for natural transformations is given by composition of the functions we use to represent them, modulo some newtype wrapping and unwrapping. Since newtypes are isomorphic to their underlying type, <code>Nat</code> wraps over <code>(-&gt;)</code>, and functions already form a category, we get the category laws for <code>Nat</code> for free. (Or at least we only had to pay for them once.)</p>

<div class="references">
</div>
<footer><hr class="footnotes"><ol class="footnotes">
<li id="fn1"><p>The terms &ldquo;mapping&rdquo;, &ldquo;arrow&rdquo;, and &ldquo;morphism&rdquo; are used pretty much interchangeably in category theory. <a href="#fnref1" class="fnref">↩</a></p></li>
<li id="fn2"><p>An <em>endofunctor</em> is a functor that maps from a category to itself. <a href="#fnref2" class="fnref">↩</a></p></li>
<li id="fn3"><p><code>PolyKinds</code> was introduced in the paper <a href="http://dreixel.net/research/pdf/ghp.pdf" title>Giving Haskell a Promotion</a> by Yorgey, Weirich, Vytiniotis, and Jones. <a href="#fnref3" class="fnref">↩</a></p></li>
</ol></footer>
</div>

      </article>

    </section>

    <script src="../js/prism.js"></script>
    <script src="../js/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/contrib/auto-render.min.js">
    </script>
    <script>
    renderMathInElement(
          document.body,
          {
              delimiters: [
                  {left: "\\[", right: "\\]", display: true},
                  {left: "\\(", right: "\\)", display: false}
              ]
          }
    );
    </script>
  </body>
</html>
